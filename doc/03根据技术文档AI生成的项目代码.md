
### 代码包文件结构
```
tamper_detection/
├── config/
│   ├── __init__.py
│   ├── paths.py
│   └── params.py
├── data/
│   ├── __init__.py
│   ├── dataset.py
│   └── preprocess.py
├── models/
│   ├── __init__.py
│   ├── resnet18.py
│   └── pscc_net.py
├── inference/
│   ├── __init__.py
│   ├── model_loader.py
│   └── predictor.py
├── frontend/
│   ├── __init__.py
│   └── app.py
├── train/
│   ├── __init__.py
│   ├── train_resnet.py
│   └── train_pscc.py
├── tests/
│   ├── __init__.py
│   ├── test_data.py
│   └── test_model.py
├── utils/
│   ├── __init__.py
│   ├── logger.py
│   └── metrics.py
├── resources/
│   ├── dataset/
│   └── pretrained_weights/
├── outputs/
├── .gitignore
├── README.md
├── requirements.txt
├── train.py
└── run.py
```


### 核心代码实现

#### 1. 配置文件
**`config/paths.py`**
```python
import os
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent.resolve()

# 资源路径
RESOURCES_DIR = PROJECT_ROOT / "resources"
DATASET_DIR = RESOURCES_DIR / "dataset"
TRAIN_DATA_DIR = DATASET_DIR / "train"
VAL_DATA_DIR = DATASET_DIR / "val"
PRETRAINED_DIR = RESOURCES_DIR / "pretrained_weights"

# 输出路径
OUTPUTS_DIR = PROJECT_ROOT / "outputs"
MODEL_SAVE_DIR = OUTPUTS_DIR / "models"
LOG_DIR = OUTPUTS_DIR / "logs"
VIS_DIR = OUTPUTS_DIR / "visualizations"

# 创建目录
for dir_path in [MODEL_SAVE_DIR, LOG_DIR, VIS_DIR]:
    dir_path.mkdir(parents=True, exist_ok=True)
```

**`config/params.py`**
```python
# 数据参数
IMAGE_SIZE = 512
BATCH_SIZE = 8
TRAIN_RATIO = 0.8

# 训练参数
RESNET_EPOCHS = 15
PSCC_EPOCHS = 20
LEARNING_RATE = 1e-4
WEIGHT_DECAY = 1e-5
STEP_SIZE = 5
GAMMA = 0.8

# 推理参数
THRESHOLD = 0.5  # 分类阈值
```


#### 2. 数据处理模块
**`data/preprocess.py`**
```python
import albumentations as A
from albumentations.pytorch import ToTensorV2

def get_train_transform(image_size=512):
    return A.Compose([
        A.Resize(height=image_size, width=image_size),
        A.HorizontalFlip(p=0.5),
        A.RandomRotate90(p=0.3),
        A.RandomBrightnessContrast(p=0.4, brightness_limit=0.2, contrast_limit=0.2),
        A.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ToTensorV2()
    ])

def get_val_transform(image_size=512):
    return A.Compose([
        A.Resize(height=image_size, width=image_size),
        A.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ToTensorV2()
    ])
```

**`data/dataset.py`**
```python
import os
import cv2
import torch
from torch.utils.data import Dataset
from config.paths import TRAIN_DATA_DIR, VAL_DATA_DIR
from data.preprocess import get_train_transform, get_val_transform

class TamperDataset(Dataset):
    def __init__(self, is_train=True, transform=None):
        self.is_train = is_train
        self.data_dir = TRAIN_DATA_DIR if is_train else VAL_DATA_DIR
        self.transform = transform or (get_train_transform() if is_train else get_val_transform())
        self.samples = self._load_samples()

    def _load_samples(self):
        samples = []
        # 加载真实图像
        pristine_dir = self.data_dir / "Pristine"
        for fname in os.listdir(pristine_dir):
            if fname.lower().endswith(('.jpg', '.png')):
                samples.append((str(pristine_dir / fname), 0))
        # 加载篡改图像
        tamper_dir = self.data_dir / "Tampered"
        for fname in os.listdir(tamper_dir):
            if fname.lower().endswith(('.jpg', '.png')):
                samples.append((str(tamper_dir / fname), 1))
        return samples

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        img_path, label = self.samples[idx]
        image = cv2.imread(img_path)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        if self.transform:
            image = self.transform(image=image)["image"]
        return image, torch.tensor(label, dtype=torch.float32)
```


#### 3. 模型定义
**`models/resnet18.py`**
```python
import torch
import torch.nn as nn
from torchvision.models import resnet18

class ResNet18Tamper(nn.Module):
    def __init__(self, pretrained=True):
        super().__init__()
        self.backbone = resnet18(pretrained=pretrained)
        self.backbone.fc = nn.Linear(self.backbone.fc.in_features, 1)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.backbone(x)
        return self.sigmoid(x)

if __name__ == "__main__":
    model = ResNet18Tamper()
    x = torch.randn(2, 3, 512, 512)
    print(model(x).shape)  # 应输出(2, 1)
```

**`models/pscc_net.py`**
```python
import torch
import torch.nn as nn

class PSCCNet(nn.Module):
    def __init__(self, in_channels=3, out_channels=1):
        super().__init__()
        # 简化版PSCC-Net结构（复用核心特征提取逻辑）
        self.encoder = nn.Sequential(
            nn.Conv2d(in_channels, 64, 3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2),
            nn.Conv2d(64, 128, 3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2),
            nn.Conv2d(128, 256, 3, padding=1),
            nn.ReLU()
        )
        self.decoder = nn.Sequential(
            nn.Conv2d(256, 128, 3, padding=1),
            nn.ReLU(),
            nn.Upsample(scale_factor=2),
            nn.Conv2d(128, 64, 3, padding=1),
            nn.ReLU(),
            nn.Upsample(scale_factor=2),
            nn.Conv2d(64, out_channels, 1)
        )
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x = self.encoder(x)
        x = self.decoder(x)
        return self.sigmoid(x)

if __name__ == "__main__":
    model = PSCCNet()
    x = torch.randn(2, 3, 512, 512)
    print(model(x).shape)  # 应输出(2, 1, 512, 512)
```


#### 4. 训练模块
**`train/train_resnet.py`**
```python
import torch
import torch.optim as optim
from torch.utils.data import DataLoader
from tqdm import tqdm
from config.paths import MODEL_SAVE_DIR, LOG_DIR
from config.params import *
from data.dataset import TamperDataset
from models.resnet18 import ResNet18Tamper
from utils.logger import get_logger
from utils.metrics import accuracy_score

logger = get_logger(LOG_DIR / "resnet_train.log")

def train_resnet(epochs=None):
    epochs = epochs or RESNET_EPOCHS
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    
    # 数据加载
    train_dataset = TamperDataset(is_train=True)
    val_dataset = TamperDataset(is_train=False)
    train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True, num_workers=2)
    val_loader = DataLoader(val_dataset, batch_size=BATCH_SIZE, shuffle=False, num_workers=2)
    
    # 模型初始化
    model = ResNet18Tamper().to(device)
    criterion = nn.BCELoss()
    optimizer = optim.Adam(model.parameters(), lr=LEARNING_RATE, weight_decay=WEIGHT_DECAY)
    scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=STEP_SIZE, gamma=GAMMA)
    
    # 训练循环
    best_acc = 0.0
    for epoch in range(epochs):
        model.train()
        train_loss = 0.0
        train_preds, train_labels = [], []
        
        for images, labels in tqdm(train_loader, desc=f"Epoch {epoch+1}/{epochs}"):
            images, labels = images.to(device), labels.to(device).unsqueeze(1)
            
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            
            train_loss += loss.item() * images.size(0)
            train_preds.extend((outputs > THRESHOLD).float().cpu().numpy())
            train_labels.extend(labels.cpu().numpy())
        
        # 验证
        model.eval()
        val_loss = 0.0
        val_preds, val_labels = [], []
        with torch.no_grad():
            for images, labels in val_loader:
                images, labels = images.to(device), labels.to(device).unsqueeze(1)
                outputs = model(images)
                loss = criterion(outputs, labels)
                val_loss += loss.item() * images.size(0)
                val_preds.extend((outputs > THRESHOLD).float().cpu().numpy())
                val_labels.extend(labels.cpu().numpy())
        
        # 计算指标
        train_acc = accuracy_score(train_labels, train_preds)
        val_acc = accuracy_score(val_labels, val_preds)
        logger.info(
            f"Epoch {epoch+1} - "
            f"Train Loss: {train_loss/len(train_dataset):.4f}, "
            f"Train Acc: {train_acc:.4f}, "
            f"Val Loss: {val_loss/len(val_dataset):.4f}, "
            f"Val Acc: {val_acc:.4f}"
        )
        
        # 保存最佳模型
        if val_acc > best_acc:
            best_acc = val_acc
            torch.save(model.state_dict(), MODEL_SAVE_DIR / "resnet18_best.pth")
        
        scheduler.step()
    
    logger.info(f"Training complete. Best Val Acc: {best_acc:.4f}")
```


#### 5. 推理模块
**`inference/model_loader.py`**
```python
import torch
from config.paths import MODEL_SAVE_DIR, PRETRAINED_DIR
from models.resnet18 import ResNet18Tamper
from models.pscc_net import PSCCNet

def load_resnet_model(pretrained=False):
    model = ResNet18Tamper(pretrained=pretrained)
    if not pretrained:
        model.load_state_dict(torch.load(MODEL_SAVE_DIR / "resnet18_best.pth", map_location="cpu"))
    model.eval()
    return model

def load_pscc_model(pretrained=False):
    model = PSCCNet()
    if not pretrained:
        model.load_state_dict(torch.load(MODEL_SAVE_DIR / "pscc_net_best.pth", map_location="cpu"))
    model.eval()
    return model
```

**`inference/predictor.py`**
```python
import torch
import cv2
import numpy as np
from data.preprocess import get_val_transform
from config.params import IMAGE_SIZE, THRESHOLD

transform = get_val_transform(IMAGE_SIZE)

def predict_single_image(model, image, is_segmentation=False):
    # 图像预处理
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    input_tensor = transform(image=image_rgb)["image"].unsqueeze(0)
    
    # 推理
    with torch.no_grad():
        output = model(input_tensor)
    
    # 后处理
    if is_segmentation:
        # 定位任务：返回掩码
        mask = output.squeeze().numpy()
        mask = cv2.resize(mask, (image.shape[1], image.shape[0]))
        return (mask > THRESHOLD).astype(np.uint8)
    else:
        # 分类任务：返回标签和置信度
        prob = output.item()
        label = "篡改图像" if prob > THRESHOLD else "真实图像"
        return label, prob
```


#### 6. 前端模块
**`frontend/app.py`**
```python
import gradio as gr
import cv2
import numpy as np
from inference.model_loader import load_resnet_model, load_pscc_model
from inference.predictor import predict_single_image

# 加载模型
resnet_model = load_resnet_model()
pscc_model = load_pscc_model()

def detect(image, model_choice):
    if image is None:
        return "请上传图像", "", None
    
    image_bgr = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
    if model_choice == "ResNet18（分类）":
        label, prob = predict_single_image(resnet_model, image_bgr)
        return label, f"置信度: {prob:.4f}", None
    else:
        label, prob = predict_single_image(resnet_model, image_bgr)
        mask = predict_single_image(pscc_model, image_bgr, is_segmentation=True)
        # 生成热力图
        heatmap = cv2.applyColorMap((mask * 255).astype(np.uint8), cv2.COLORMAP_JET)
        overlay = cv2.addWeighted(image, 0.7, heatmap, 0.3, 0)
        return label, f"置信度: {prob:.4f}", overlay

def launch_app(**kwargs):
    with gr.Blocks(title="图像篡改检测系统") as demo:
        gr.Markdown("# 图像篡改检测学习系统")
        with gr.Row():
            with gr.Column(scale=1):
                image_input = gr.Image(type="numpy", label="上传图像")
                model_choice = gr.Radio(
                    ["ResNet18（分类）", "PSCC-Net（带定位）"],
                    label="模型选择",
                    value="ResNet18（分类）"
                )
                detect_btn = gr.Button("开始检测")
            with gr.Column(scale=1):
                label_output = gr.Textbox(label="检测结果")
                prob_output = gr.Textbox(label="置信度")
                heatmap_output = gr.Image(label="篡改区域热力图", visible=False)
        
        detect_btn.click(
            fn=detect,
            inputs=[image_input, model_choice],
            outputs=[label_output, prob_output, heatmap_output]
        )
        model_choice.change(
            fn=lambda x: gr.update(visible=(x == "PSCC-Net（带定位）")),
            inputs=model_choice,
            outputs=heatmap_output
        )
    
    demo.launch(** kwargs)
```


#### 7. 工具模块
**`utils/logger.py`**
```python
import logging
from pathlib import Path

def get_logger(log_path):
    logger = logging.getLogger("tamper_detection")
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    
    # 文件处理器
    file_handler = logging.FileHandler(log_path)
    file_handler.setFormatter(formatter)
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    return logger
```

**`utils/metrics.py`**
```python
import numpy as np
from sklearn.metrics import accuracy_score, f1_score, confusion_matrix

def accuracy_score(y_true, y_pred):
    return accuracy_score(np.array(y_true), np.array(y_pred))

def f1_score(y_true, y_pred):
    return f1_score(np.array(y_true), np.array(y_pred))

def iou_score(mask_true, mask_pred):
    intersection = np.logical_and(mask_true, mask_pred).sum()
    union = np.logical_or(mask_true, mask_pred).sum()
    return intersection / union if union > 0 else 0
```


#### 8. 入口脚本
**`train.py`**
```python
import argparse
from train.train_resnet import train_resnet
from train.train_pscc import train_pscc

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--model", type=str, choices=["resnet18", "pscc_net"], default="resnet18")
    parser.add_argument("--epochs", type=int, default=None)
    args = parser.parse_args()
    
    if args.model == "resnet18":
        train_resnet(args.epochs)
    else:
        train_pscc(args.epochs)
```

**`run.py`**
```python
from frontend.app import launch_app

if __name__ == "__main__":
    launch_app(server_name="0.0.0.0", server_port=7860)
```


#### 9. 依赖与说明
**`requirements.txt`**
```
torch==2.0.1
torchvision==0.15.2
opencv-python==4.8.0.76
albumentations==1.3.0
gradio==3.35.2
matplotlib==3.7.1
scikit-learn==1.3.0
tqdm==4.65.0
```

**`README.md`**
```markdown
# 图像篡改检测项目

## 快速开始
1. 安装依赖：`pip install -r requirements.txt`
2. 准备数据：将数据集放入`resources/dataset`
3. 训练模型：`python train.py --model resnet18`
4. 启动服务：`python run.py`

## 项目结构
- `config/`: 配置文件
- `data/`: 数据处理
- `models/`: 模型定义
- `train/`: 训练脚本
- `inference/`: 推理逻辑
- `frontend/`: 前端界面
```


### 使用说明
1. 将PSCC-Net合成数据集按`Pristine`和`Tampered`分类放入`resources/dataset/train`和`val`目录
2. 先运行训练脚本生成模型权重
3. 启动前端服务后，通过浏览器访问`http://localhost:7860`使用系统

该代码包已预留扩展接口，支持后续添加新模型和功能，适合团队分工开发与学习使用。